//! Example demonstrating memory-mapped I/O for large binary PLY/PCD files
//!
//! This example shows how to use the io-mmap feature for improved performance
//! when reading large binary point cloud files.

use std::time::Instant;
use threecrate_core::{PointCloud, Point3f};
use threecrate_io::{RobustPlyReader, RobustPlyWriter, PlyWriteOptions};
use threecrate_io::{RobustPcdReader, RobustPcdWriter, PcdWriteOptions, PcdDataFormat};

/// Generate a large test point cloud
fn generate_large_point_cloud(num_points: usize) -> PointCloud<Point3f> {
    println!("Generating {} points...", num_points);
    
    let points: Vec<Point3f> = (0..num_points)
        .map(|i| {
            let i = i as f32;
            let theta = i * 0.01;
            let phi = i * 0.005;
            Point3f::new(
                theta.sin() * phi.cos(),
                theta.sin() * phi.sin(),
                theta.cos(),
            )
        })
        .collect();
    
    PointCloud::from_points(points)
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("Memory-mapped I/O Example for threecrate-io");
    println!("============================================\n");
    
    // Check if memory mapping is supported on this platform
    #[cfg(feature = "io-mmap")]
    {
        let supported = threecrate_io::mmap::MmapReader::is_supported();
        println!("Memory mapping supported: {}", supported);
    }
    
    #[cfg(not(feature = "io-mmap"))]
    {
        println!("Memory mapping feature not enabled. Compile with --features io-mmap to enable.");
        println!("Continuing with standard buffered I/O...\n");
    }
    
    // Generate test data
    let num_points = 100_000;
    let cloud = generate_large_point_cloud(num_points);
    
    // Test PLY format
    println!("Testing Binary PLY Format:");
    println!("--------------------------");
    
    // Write binary PLY file
    let ply_path = "test_large.ply";
    let ply_options = PlyWriteOptions::binary_little_endian()
        .with_comment("Generated by mmap_example.rs")
        .with_comment(format!("Contains {} points", num_points));
    
    println!("Writing binary PLY file...");
    let start = Instant::now();
    RobustPlyWriter::write_point_cloud(&cloud, ply_path, &ply_options)?;
    let write_time = start.elapsed();
    println!("Write time: {:?}", write_time);
    
    // Get file size
    let file_size = std::fs::metadata(ply_path)?.len();
    println!("File size: {} bytes ({:.2} MB)", file_size, file_size as f64 / 1_048_576.0);
    
    // Check if this file would use memory mapping
    #[cfg(feature = "io-mmap")]
    {
        let should_mmap = threecrate_io::mmap::should_use_mmap(ply_path);
        println!("Would use memory mapping: {}", should_mmap);
    }
    
    // Read PLY file (will use mmap if available and beneficial)
    println!("Reading binary PLY file...");
    let start = Instant::now();
    let ply_data = RobustPlyReader::read_ply_file(ply_path)?;
    let read_time = start.elapsed();
    println!("Read time: {:?}", read_time);
    
    // Verify data integrity
    if let Some(vertices) = ply_data.elements.get("vertex") {
        println!("Successfully read {} vertices", vertices.len());
        assert_eq!(vertices.len(), num_points);
    }
    
    // Test PCD format
    println!("\nTesting Binary PCD Format:");
    println!("--------------------------");
    
    // Write binary PCD file
    let pcd_path = "test_large.pcd";
    let pcd_options = PcdWriteOptions {
        data_format: PcdDataFormat::Binary,
        version: "0.7".to_string(),
        ..Default::default()
    };
    
    println!("Writing binary PCD file...");
    let start = Instant::now();
    RobustPcdWriter::write_point_cloud(&cloud, pcd_path, &pcd_options)?;
    let write_time = start.elapsed();
    println!("Write time: {:?}", write_time);
    
    // Get file size
    let file_size = std::fs::metadata(pcd_path)?.len();
    println!("File size: {} bytes ({:.2} MB)", file_size, file_size as f64 / 1_048_576.0);
    
    // Check if this file would use memory mapping
    #[cfg(feature = "io-mmap")]
    {
        let should_mmap = threecrate_io::mmap::should_use_mmap(pcd_path);
        println!("Would use memory mapping: {}", should_mmap);
    }
    
    // Read PCD file (will use mmap if available and beneficial)
    println!("Reading binary PCD file...");
    let start = Instant::now();
    let (pcd_header, pcd_points) = RobustPcdReader::read_pcd_file(pcd_path)?;
    let read_time = start.elapsed();
    println!("Read time: {:?}", read_time);
    
    // Verify data integrity
    println!("Successfully read {} points", pcd_points.len());
    assert_eq!(pcd_points.len(), num_points);
    
    // Convert back to point cloud to verify
    let recovered_cloud = RobustPcdReader::pcd_to_point_cloud(&pcd_header, &pcd_points)?;
    println!("Converted to point cloud with {} points", recovered_cloud.len());
    
    // Performance comparison (if mmap is available)
    #[cfg(feature = "io-mmap")]
    {
        println!("\nPerformance Comparison:");
        println!("----------------------");
        
        // Time standard buffered I/O
        println!("Testing standard buffered I/O...");
        let start = Instant::now();
        let file = std::fs::File::open(ply_path)?;
        let mut reader = std::io::BufReader::new(file);
        let _ply_data = RobustPlyReader::read_ply_data(&mut reader)?;
        let buffered_time = start.elapsed();
        
        // Time memory-mapped I/O (implicit in read_ply_file)
        println!("Testing memory-mapped I/O...");
        let start = Instant::now();
        let _ply_data = RobustPlyReader::read_ply_file(ply_path)?;
        let mmap_time = start.elapsed();
        
        println!("Buffered I/O time: {:?}", buffered_time);
        println!("Memory-mapped I/O time: {:?}", mmap_time);
        
        if mmap_time < buffered_time {
            let speedup = buffered_time.as_nanos() as f64 / mmap_time.as_nanos() as f64;
            println!("Memory mapping is {:.2}x faster!", speedup);
        } else {
            println!("Standard buffered I/O was faster for this file size.");
        }
    }
    
    // Clean up
    std::fs::remove_file(ply_path).ok();
    std::fs::remove_file(pcd_path).ok();
    
    println!("\nExample completed successfully!");
    println!("\nTo run benchmarks comparing mmap vs buffered I/O:");
    println!("cargo bench --features io-mmap mmap_benchmarks");
    
    Ok(())
}
